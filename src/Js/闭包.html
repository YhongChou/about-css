<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
    // 1
    // var b = 3;
    // function fn() {
    //     var a = 1;
    //     console.log('b', b);// b
    // }

    // fn();
    // console.log(a);// 访问不到 报错

    // 2
    // function fn2() {
    //     var a = 1;
    //     function fn2() {
    //         a++
    //         return a;
    //     }
    //     return fn2;
    // }
    // var f = fn2(); // 创建一次闭包

    // // 3 将函数作为另一个函数的返回值
    // // 3.1 闭包在预解析阶段产生（函数提升，内部函数对象已声明
    // function fn1() {
    //     var a = 1;
    //     function fn2() {// 执行完后 fn2这个对象被释放
    //         a++ // 闭包中只包含a变量，执行完后，没被释放
    //         console.log(a);
    //         return a;
    //     }
    //     // 3.1 fn2()执行完后闭包才产生
    //     var fn2 = function() {// 执行完后 fn2这个对象被释放
    //         a++ // 闭包中只包含a变量，执行完后，没被释放
    //         console.log(a);
    //         return a;
    //     }
    //     return fn2;
    // }
    // var f = fn1(); // 调用外部函数 创建一次闭包
    // f(); // 2 f()执行的是fn2 调用内部函数
    // f(); // 3
    // // 3.2 闭包死亡，闭包函数对象成为垃圾对象
    // f = null 
    // fn1()() // 重新创建一次闭包 2

    // // 4 将函数作为实参传递给另一个函数
    // function showDelay(msg, time) {
    //     // function是一个函数，已经形成闭包，被引用的变量是msg
    //     setTimeout(function(){
    //         console.log(msg)
    //     }, time);
    // }
    // showDelay('bibao', 1000);
    
    
    // // 拿到a 实现在函数外部访问到函数内部的变量
    // // const res = fn();

    // // 立即执行函数,返回内部封装的对象
    // const module = (function fn3() {
    //     var a = 0;
    //     var b = 0;
    //     // 1、返回数组
    //     // return [
    //     //     // 需要是匿名函数
    //     //     // function a() {
    //     //     //     return a;
    //     //     // },
    //     //     function() {
    //     //         return b;
    //     //     }
    //     // ]
    //     // 2、返回对象
    //     // return {
    //     //     getA: function() {
    //     //         return a;
    //     //     },
    //     //     getB: function() {
    //     //         return b;
    //     //     },
    //     // }
    //     function getA() {
    //         return a;
    //     }
    //     function getB() {
    //         return b;
    //     }

    //     function setA(value) {
    //         a = value
    //     }
    //     function setB(value) {
    //         b = value
    //     }

    //     return {
    //         getA: getA,
    //         getB: getB,
    //         setA: setA,
    //         setB: setB
    //     }
    // })();
    // // const res1 = fn3();
    // // // 因为返回的是方法，所以要加()调用
    // // // const a = res1[0]();
    // // let a = res1.getA();
    // // let b = res1.getB();
    // // console.log(a, b);
    // // res1.setA()

    // // module.setA(2);
    // // const a = module.getA();
    // // console.log(a);

    // for(var i=0; i < 10; i++) {
    //     setTimeout(function() {
    //         console.log(i)// 都是10
    //     }, 1000)
    // }

    // // 用立即执行实现, 不会等1s
    // for(var i=0; i < 10; i++) {
    //     setTimeout(
    //         (function() {
    //             console.log(i)// 0 ... 9
    //         })()
    //     , 1000)
    // }

    // // 用闭包实现,1s之后输出
    // for(var i = 0; i < 10; i++) {
    //     function fun() {
    //         return function(j) {
    //             console.log(j);
    //         }
    //     }
    //     // i表示传入的实参
    //     setTimeout(fun(), 1000, i)
    // }

    </script>

</body>
</html>
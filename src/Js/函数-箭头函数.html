<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
    <button id="button">
        button
    </button>
<body>
    <script>
        // // 1 概念
        // const a = [1, 2];
        // console.log(...a); // 1 2
        // console.log(...[a]); // [1,2]
        // console.log([...a]); // [1,2]
        // console.log(...[[a]]); // [[1,2]]
        // console.log([...[a], ...[a]]); // [[1,2], [1,2]]

        // 2 箭头函数
        // const full = ({first, last} = {}) => first + '' + last;
        // console.log(full({first: 4, last: 5}));

        // // 等价于
        // function full({first, last} = {}){
        //     return first + '' + last
        // }

        // 3 箭头函数的形参
        // var sum = (...args) => {
        //     console.log(args) // Array
        // }

        // sum(1, 2);
        
        // 等价于
        // var sum = (x, y) => {
        //     console.log(x, y) // Array
        // }

        // sum(...[1, 2]);

        // // 4 函数参数 ... rest 打散、展开运算符
        // function foo(x, y, z) {
        //     console.log(this); 
        //     console.log(x, y, z) // 数组解构匹配 1 2 3
        // }

        // foo(...[1, 2, 3, 4]); // window
        // // this指向不发生改变，传null、undefined
        // foo.apply(null, [1, 2, 3, 4]); // window
        // foo.apply(undefined, [1, 2, 3, 4]); // window

        // // 5 rest展开合并数组 ...
        // let a = [2, 3, 4];
        // let b = [1, ...a, 5];
        // console.log(b); // [1, 2, 3, 4, 5]

        // // 6 rest收集剩余的参数 收集为一个数组, ...只能放在最后
        // let fn = (a, b, ...c) => {
        //     console.log(a, b, c) // 1 2 (4) [3, 4, 5, 6]
        // }

        // fn(1, 2, 3, 4, 5, 6);

        // // 7 类数组排序
        // function sort() {
        //     return Array.prototype.slice.call(arguments).sort(
        //         function(a, b) {
        //             return a-b
        //         }
        //     );
        // }
        // sort(33345, 345, 456);

        // // 7.1 用箭头函数改写
        // const sort = (...args) => args.sort((a, b) => a - b);
        // console.log(sort(33345, 345, 456));

        // // 8.1 箭头函数的this
        // function foo() {
        //     return a => {
        //         console.log(this.a)
        //     }
        // }

        // var obj1 = {a: 2};
        // var obj2 = {a: 3};
        // var bar = foo.call(obj1); // this指向obj1 2
        // bar.call(obj2); // this仍然指向obj1 2

        // // 8.2 箭头函数的this
        // const person = {
        //     eat() {
        //         console.log(this)
        //     },
        //     drink: () => {
        //         console.log(this)
        //     }
        // }

        // person.eat(); // person调用eat方法,this指向person
        // person.drink(); // drink定义时父级是window 

        // // 8.3 监听click事件
        // (function() {
        //     function Button() {
        //         console.log('Button', this); // Button
        //         this.button = document.getElementById('button')
        //     }

        //     Button.prototype = {
        //         init() {
        //             this.bindEvent();
        //         },
                // bindEvent() {
                //     console.log('bindEvent', this.button, this); // buttonDom Button
                //     // this.button.addEventListener('click', 
                //     //     this.clickBtn.bind(this),
                //     //     false
                //     // )

                //     // 用箭头函数固化this
                //     this.button.addEventListener('click', e => {
                //         this.clickBtn(e), // this始终指向Button
                //         false
                //     })
                // },
        //         clickBtn(e) {
        //             console.log('clickBtn', this) // Button
        //         }
        //     }

        //     new Button().init(); //this指向Button
        // })();

        // // 8.4 箭头函数的this指向父级作用域的this，如果父级没有，就继续往上找
        // // 箭头函数的this 指向foo函数作用域的this
        // function foo() {
        //     return () => {
        //         return () => {
        //             return () => {
        //                 console.log('id', this.id)
        //             }
        //         }
        //     }
        // }

        // var f = foo.call({id: 1});
        // var f1 = f.call({id: 2})()(); // 1
        // var f2 = f().call({id: 1})(); // 1
        // var f3 = f()().call({id: 4}); // 1

        // // 9 没有arguments
        // function foo() {
        //     console.log(arguments)
        //     setTimeout(
        //         // 引用了父级的arguments,相当于生成了一个闭包
        //         () => {
        //         console.log(arguments) 
        //     })
        // }
        // foo(1, 2, 3)

        // function insert(value) {
        //     return {
        //         into: function(array) {
        //             return {
        //                 after: function(afterValue) {
        //                     array.splice(array.indexOf(afterValue) + 1, 0, value);
        //                     return array;
        //                 }
        //             }
        //         }
        //     }
        // }

        // console.log(insert(5).into([1, 2, 3, 4]).after(4));

        // // 需要用()括起来，表示一个表达式，返回的是一个对象，而不是一个块级作用域
        // let insert = value => ({
        //     into: array => ({
        //         after: afterValue => {
        //             array.splice(array.indexOf(afterValue) + 1, 0, value);
        //             return array;
        //         }
        //     })
        // })

        // console.log(insert(5).into([1, 2, 3, 4]).after(4));

    </script>
</body>
</html>